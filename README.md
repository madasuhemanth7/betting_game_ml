# betting_game_ml
A Python project simulating betting games with machine learning for match prediction.
## Betting Game Project: ML-Powered Match Prediction

This project demonstrates a basic framework for a betting game, focusing on the application of machine learning to predict outcomes. We'll simulate a highly simplified "sports match" scenario where two teams, Team A and Team B, compete. The goal is to predict which team will win based on some generated historical performance metrics.

### Project Components:

1.  **`data_generator.py`**: This script will create a synthetic dataset. Real-world sports data is complex and requires extensive collection; for this example, we'll generate data that mimics some basic features influencing match outcomes.
    * **Features:**
        * `team_a_form`: A numerical representation of Team A's recent performance/form.
        * `team_b_form`: A numerical representation of Team B's recent performance/form.
        * `team_a_win_rate`: Team A's historical win rate.
        * `team_b_win_rate`: Team B's historical win rate.
    * **Target Variable:**
        * `outcome`: A binary variable (0 or 1), where 1 indicates Team A wins, and 0 indicates Team B wins. The outcome will be probabilistically linked to the input features.

2.  **`ml_predictor.py`**: This script will handle the machine learning aspect.
    * It will load the dataset generated by `data_generator.py`.
    * It will split the data into training and testing sets.
    * It will train a `LogisticRegression` model from `scikit-learn` to predict the `outcome` based on the team statistics.
    * It will evaluate the model's performance (e.g., accuracy).
    * It will save the trained model for later use.

3.  **`betting_simulator.py`**: This script will simulate the betting game.
    * It will load the trained ML model.
    * For a series of simulated matches, it will:
        * Generate new match statistics.
        * Use the ML model to predict the outcome.
        * Place a "bet" based on the prediction.
        * Determine the actual outcome of the simulated match (with some randomness, but influenced by the stats).
        * Calculate the profit or loss from the bet.
    * It will keep track of the total profit/loss over all simulated bets.

### How it Works:

The `data_generator.py` script will create a CSV file named `match_data.csv`. This file will serve as our "historical" data.

The `ml_predictor.py` script will then use this `match_data.csv` to train a model. The model learns the relationship between the team forms/win rates and the match outcome.

Finally, the `betting_simulator.py` will use this trained model to make predictions on *new* simulated matches. Based on the prediction, it will place a bet. The actual outcome of these new matches is then randomly determined (but still influenced by the underlying stats), and the profit/loss is calculated. This allows us to see how well our ML-powered betting strategy performs.

This project is a simplified demonstration and is not intended for real-world financial betting, as actual betting involves many more complex factors, odds, and risks.

---

### Dataset Explanation (`match_data.csv`)

The `match_data.csv` file, generated by `data_generator.py`, represents our synthetic historical data. Each row in this dataset corresponds to a single simulated match.

**Columns:**

* **`team_a_form`**: A floating-point number between 0 and 1, indicating the recent performance or "form" of Team A. A higher value suggests better recent performance.
* **`team_b_form`**: Similar to `team_a_form`, but for Team B.
* **`team_a_win_rate`**: A floating-point number between 0 and 1, representing Team A's historical win rate. A higher value means Team A historically wins more often.
* **`team_b_win_rate`**: Similar to `team_a_win_rate`, but for Team B.
* **`outcome`**: This is our target variable. It's a binary integer:
    * `1`: Team A won the match.
    * `0`: Team B won the match.

The `outcome` is generated such that it has a probabilistic relationship with the `form` and `win_rate` differences between the teams. For instance, if `team_a_form` is significantly higher than `team_b_form`, Team A has a higher probability of winning, but there's always an element of randomness to simulate upsets or unpredictable events in sports.

This dataset serves as the "knowledge base" for our machine learning model to learn from.

### Machine Learning (ML) Explanation

In this project, we use a **Logistic Regression** model.

**Why Logistic Regression?**

* **Classification Task:** Our goal is to predict a binary outcome (Team A wins or Team B wins), which is a classification problem. Logistic Regression is a fundamental and effective algorithm for binary classification.
* **Interpretability:** It's relatively easy to understand how Logistic Regression makes its predictions, as it models the probability of the outcome based on a linear combination of the input features.
* **Simplicity:** For a demonstration project, it's a good starting point before exploring more complex models.

**How the ML Model Works (`ml_predictor.py`):**

1.  **Data Loading:** The script first loads the `match_data.csv` into a Pandas DataFrame.
2.  **Feature and Target Separation:**
    * **Features (X):** The input variables used to make predictions. In our case, these are `team_a_form`, `team_b_form`, `team_a_win_rate`, and `team_b_win_rate`.
    * **Target (y):** The variable we want to predict, which is `outcome`.
3.  **Data Splitting:** The dataset is divided into two parts:
    * **Training Set (80%):** Used to train the model. The model learns the patterns and relationships between the features and the outcome from this data.
    * **Testing Set (20%):** Used to evaluate how well the trained model performs on *unseen* data. This gives us an idea of the model's generalization ability.
4.  **Model Training:**
    * A `LogisticRegression` model is initialized.
    * The `fit()` method is called on the training data (`X_train`, `y_train`). During this step, the model adjusts its internal parameters to minimize the prediction error.
5.  **Model Evaluation:**
    * After training, the model makes predictions on the `X_test` data.
    * **Accuracy Score:** This metric tells us the proportion of correctly predicted outcomes on the test set. For example, an accuracy of 0.75 means the model correctly predicted 75% of the match outcomes in the test set.
    * **Classification Report:** Provides more detailed metrics like precision, recall, and F1-score for each class (Team A win, Team B win), giving a more nuanced view of the model's performance.
6.  **Model Saving:** The trained model is saved to a file (`betting_model.pkl`) using `joblib`. This allows us to load the model later in the `betting_simulator.py` script without having to retrain it every time.

**Using the Model in Betting (`betting_simulator.py`):**

1.  **Model Loading:** The `betting_simulator.py` script loads the pre-trained model.
2.  **Simulated Matches:** For each new simulated match:
    * New, random team statistics are generated (similar to how the training data was generated, but these are *new* matches).
    * These new statistics are fed into the loaded ML model's `predict()` method.
    * The model outputs its predicted outcome (1 for Team A win, 0 for Team B win).
3.  **Betting Decision:** A simple betting strategy is applied: if the model predicts Team A wins, we bet on Team A; otherwise, we bet on Team B.
4.  **Actual Outcome Simulation:** The actual outcome of the simulated match is determined using a probabilistic function, again influenced by the team statistics, but with its own element of randomness. This simulates the real-world uncertainty.
5.  **Profit/Loss Calculation:** The predicted outcome is compared to the actual outcome. If they match, a profit is recorded; otherwise, a loss. The total profit/loss is tracked over all simulations.

This entire process demonstrates a basic pipeline from data generation to model training and its application in a simulated scenario.